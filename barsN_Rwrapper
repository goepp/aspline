#
# /**********************************************************************
#		
#			Rwrapper for BARSN v. 1.0
#
#
#
# This program is free software; you can distribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2, or (at your option) any
# later version.
#  
# These functions are distributed in the hope that they will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# The text of the GNU General Public License, version 2, is available
# as http://www.gnu.org/copyleft or by writing to the Free Software
# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#
#
# Credits and Acknowledgements:
#
#   This Rwrapper is designed to work with Wallstrom and Kass's
#   Barslib, (C) 2003.
#
#   Barslib uses Hansen and Kooperberg's Logspline, (C) 1997, as the
#   default method for selecting initial knots.
#
#   Barslib uses Bates and Venables Routines for manipulating B-splines, (C)
#   1998. The routines were released under the same GNU General Public
#   License referred to above.
#
#
# ************************************************************************/
#
#
# /****************************************************************************
#
# barsN.fun(x,y,initial,iknots,prior,priorparam,burnin,sims,
#		tau,c,fits,peak,conf)
#
# Prior to using this Rwrapper, one must have a shared object file called
# barsN.so.  This can be created on linux by giving the command 
#         R CMD SHLIB barsN.c
# Make sure that you have barsN.out before executing this command.
# You must make the shared library available with the
# dyn.load("barsN.so",now=F) command.  Also, the barsN.c program must
# be properly compiled, with the compiled program saved as barsN.out.
#
#  WARNING:
# Please note that this program creates or overwrites several files,
# entitled "bars_points", "bars_params", "samp_mu", "samp_params",
# "summ_mu", "summ_mugrid", "summ_params", "prior_knots", and
# "samp_knots".  Care should be made to avoid accidentally deleting files. 
# 
#
# This R wrapper for the BARS code has the following input:
#
# Required: 
#
#  x  
#     a vector of the independent variable, in increasing order
#
#  y   
#     a vector of the dependent variable
#
#
# Optional:
#
# Initial knots settings (optional):
#
#  iknots
#     the initial number of knots for the spline (default = 25)
#
#
# Settings on prior for knots (optional):
#
#  prior
#     the type of prior being used for the knots (the only acceptable
#       answers are "Poisson", "uniform", and "user"  - default = "uniform")
#
#  priorparam
#     the parameter for the prior
#     a) if using Poisson, the choice for lambda = mean 
#     b) if using Uniform, a vector of length 2 which includes the
#	minimum number of knots followed by the maximum number of
#	knots  (default = c(1,60))
#     c) if using user-defined prior, a matrix with 2 columns.  The
#	first column should be the number of knots and the second column
#	should be the probability of obtaining this number of knots.
#	Note the following example:
#     
#		2 0.05
#		3 0.15
#		4 0.30
#		5 0.30
#		6 0.10
#		7 0.10
#
# MCMC settings (optional):
# 
#  burnin
#     the desired length of the burn-in for the MCMC chain 
#	 (default = 200)
#
#  sims
#     the number of simulations desired for the MCMC chain 
#	 (default = 2000)
#
#  tau 
#     parameter that controls the spread for the knot proposal
#       distribution (default = 50.0) 
# 
#  c 
#     parameter that controls the probability of birth and death
#       candidates (default = 0.4)
#
#
# Output settings (optional):
#
#  fits
#     if "T", the program will return the fitted values for each
#       data point for each run of the simulation (default = T)  Please
#       note that if the number of data points and/or simulations is
#       large, there may be a lengthy delay as the necessary data is
#       read.  
#
#  peak
#     if "T", the program will return the location and height of the
#       highest point on the fitted curve (default = F)
#
#  conf
#     for use with peak.  Sets the limits for the credible intervals
#       for the location and height of the peak.  (default = 0.95 for 95%
#       credible intervals).
#
# Other settings (optional):
#
#
#  bins
#     the number of bins one desires the x-axis to be divided into -
#       used to handle unbinned data and calculate posterior modes
#       (default = 150)
#
#
# Note that due to the large amount of output generated by the program,
# it is desirable to save the results of the program into a
# variable, such as:
#
# out <- barsN.fun(x,y,.....)
# 
#
# The Rwrapper performs the operation by reading the data into the
# file "bars_points", reading the settings into the file "bars_params" and
# running the program in a linux setting.  The following information is
# returned in the output:
#
#
# postmeans 
#    vector of the posterior means evaluated at the x values
#
# postmodes 
#    vector of the posterior modes evaluated at the x values
#
# sims 
#    vector of each trial number, beginning at burnin + 1 and
#       ending at burnin + sims
#
# no.knots 
#    vector of the number of knots used at each trial (does not include
#       burnin iterations)
#
# sampknots
#    matrix containing the position of the knots at each iteration.
#       Length of the matrix is equal to the number of iterations, not
#       including burnin iterations, with the width of the matrix equal to
#       the maximum number of knots at any iteration.  NAs are used to
#       fill in the matrix at iteration numbers that have less than the
#       maximum number of knots.
#
# sampBICs 
#    vector of the calculated BIC at each trial (does not include burnin
#       iterations) 
#
# sampllikes 
#    vector of the calculated loglikelihood at each trial (does not
#       include burnin iterations)
#
#
# Optional output if fits = "T":
#
# sampfits
#    matrix of fits for each trial (does not include burnin
#       iterations), with the rows of the matrix corresponding to the
#       individual trial.  The columns represent the fits at each value
#       of x.
#
#
# Optional output if peak = "T":
#
# samplpeaks 
#    vector of the x location of the highest point in the fitted
#       curve for each trial (does not include burnin iterations)
#
# samphpeaks 
#    vector of the y value (height) of the highest point in the
#       fitted curve for each trial (does not include burnin iterations)
#
# peaklocationquantile
#    a credible interval for the x location of the highest peak; width
#       of the interval is dependent upon the setting chosen for conf
#
# peaklocationmean 
#    the mean x location for the highest peak
#
# peaklocationmode 
#    the mode x location for the highest peak
#
# peakheightquantile 
#    a credible interval for the y value (height) of the highest peak;
#       width of the interval is dependent upon the setting chosen for
#       conf
#
# peakheightmean 
#    the mean y value (height) of the highest peak
#
# peakheightmode 
#    the mode y value (height) of the highest peak
#
#  
# ****************************************************************************/

barsN.fun<-function(x,y,iknots=25,prior="uniform",
priorparam=c(1,60),burnin=200,sims=2000,tau=50.0,c=0.4,fits=T,
peak=F,conf=0.95,bins=150){
x<-as.double(x)
y<-as.double(y)
n<-length(x)
n<-as.integer(n)
if(length(y)!=n){
print("x and y are not the same length")
break}

burnin<-as.integer(burnin)
sims<-as.integer(sims)
iknots<-as.integer(iknots)
prior<-as.character(prior)
tau<-as.double(tau)
c<-as.double(c)
if(c>0.5 || c<=0){
print("Value of c must be greater than 0 and no greater than 0.5")
break}
bins<-as.integer(bins)

.C("filed",x,y,n)
.C("priorsetup",burnin,sims,iknots,tau,c,conf,bins)
z<-0
if(prior=="Poisson" || prior=="Pois" || prior=="poisson" || prior=="pois"){
priorparam<-as.double(priorparam)
.C("paramp",priorparam)
z<-1}

if(prior=="Uniform" || prior=="Unif" || prior=="uniform" || prior=="unif"){
if(length(priorparam)!=2){
print("Uniform prior requires a vector of length 2 - a minimum number")
print("of knots and a maximum number of knots")
break}
upper<-priorparam[2]
lower<-priorparam[1]
if(lower>upper){
print("Lower bound is greater than upper bound for number of knots")
break}
if(lower<1){
print("Lower bound is less than 1 and has been reset to 1 knot.")
lower<-1}
upper<-as.integer(upper)
lower<-as.integer(lower)
.C("paramu",upper,lower)
z<-1}

if(prior=="User"||
prior=="user"||prior=="defined"||prior=="other"||prior=="Other"){
if(ncol(priorparam)!=2){
print("For user defined prior, priorparam must be of the form")
print("of an nx2 matrix, with the number of knots in the first")
print("column and the probability of obtaining that number of knots")
print("in the second column.")
break}
pknots<-as.integer(priorparam[,1])
probknots<-as.double(priorparam[,2])
knotlength<-as.integer(length(pknots))
.C("filed2",pknots,probknots,knotlength)
.C("paramuser")
z<-2}

if(z==0){
print("Prior must be Poisson, uniform, or user-defined.")
break}


if(z==1){
system("./barsN.out bars_points bars_params")
}

if(z==2){
system("./barsN.out bars_points bars_params prior_file")
}

v<-scan("samp_params")
if(length(v)==0){
	print("Program failed to generate correct knots.")
	print("Problem is likely due to poor constraints on prior.")
	print("Try again with smaller lower bound on prior.")
break}

sumfits<-as.matrix(read.table("summ_mu"))
sampmeans<-as.matrix(read.table("samp_params"))
summar<-as.matrix(read.table("summ_params"))
lengths<-count.fields("samp_knots")
knots1<-scan("samp_knots")
knots<-matrix(NA,ncol=max(lengths),nrow=length(lengths))
index<-c(0,cumsum(lengths))
for(i in 1:length(lengths)){
knots[i,1:lengths[i]]<-knots1[ (index[i]+1):index[(i+1)] ]
}


if(fits==T){
	sampfit<-as.matrix(read.table("samp_mu"))
	sampfit<-sampfit+(min(y)-0.1)
if(peak==T){
	summar<-as.matrix(read.table("summ_params"))
g<-list(sampfits=sampfit,postmeans=(sumfits[2,]),
	postmodes=(sumfits[3,]),
	sims=sampmeans[,1],no.knots=sampmeans[,6],sampknots=knots,
	sampBICs=sampmeans[,2],
	sampllikes=sampmeans[,3],samplpeaks=sampmeans[,4],
	samphpeaks=(sampmeans[,5]),
	peaklocationquantile=summar[1,1:2],
	peaklocationmean=summar[1,3],peaklocationmode=summar[1,4],
	peakheightquantile=(summar[2,1:2]),
	peakheightmean=(summar[2,3]),
	peakheightmode=(summar[2,4]))}
if(peak==F){
g<-list(sampfits=sampfit,postmeans=(sumfits[2,]),
	postmodes=(sumfits[3,]),
	sims=sampmeans[,1],no.knots=sampmeans[,6],sampknots=knots,
	sampBICs=sampmeans[,2],
	sampllikes=sampmeans[,3])
}
}

if(fits==F){
if(peak==T){
summar<-as.matrix(read.table("summ_params"))
g<-list(postmeans=(sumfits[2,]),
	postmodes=(sumfits[3,]),
	sims=sampmeans[,1],no.knots=sampmeans[,6],sampknots=knots,
	sampBICs=sampmeans[,2],
	sampllikes=sampmeans[,3],samplpeaks=sampmeans[,4],
	samphpeaks=(sampmeans[,5]),
	peaklocationquantile=summar[1,1:2],
	peaklocationmean=summar[1,3],peaklocationmode=summar[1,4],
	peakheightquantile=(summar[2,1:2]),
	peakheightmean=(summar[2,3]),
	peakheightmode=(summar[2,4]))}
if(peak==F){
g<-list(postmeans=(sumfits[2,]),
	postmodes=(sumfits[3,]),
	sims=sampmeans[,1],no.knots=sampmeans[,6],sampknots=knots,
	sampBICs=sampmeans[,2],
	sampllikes=sampmeans[,3])
}
}
return(g)
}

